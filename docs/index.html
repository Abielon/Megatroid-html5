<!DOCTYPE html>

<!--
     Custom HTML shell for Megatroid (HTML5/Emscripten) with first-run fullscreen + landscape lock
     - Drops into UE4 HTML template location: "YourProject/Build/HTML/GameX.html.template"
     - Uses an in-page first-run fullscreen+orientation attempt, then switches to a simple fullscreen handler.
     - Includes a robust rotate+scale CSS fallback for browsers (notably iOS) that do not support orientation.lock.
-->

<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Megatroid</title>

    <!-- Local dependencies (expected next to this file) -->
    <script src="jquery-2.1.3.min.js"></script>
    <script src="bootstrap.min.js"></script>
    <link href="bootstrap.min.css" rel="stylesheet">

    <link href="Megatroid-HTML5-Shipping.css" rel="stylesheet">

    <style>
    /* Fallback UI & rotate+scale wrapper for platforms without orientation.lock */
    .force-landscape-fallback .rotate-scale-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: black;
      z-index: 999999;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* The element that will be rotated + scaled */
    .rotate-scale-wrapper .rotate-content {
      position: relative;
      width: 100%;
      height: 100%;
      transform-origin: center center;
      will-change: transform;
      display: block;
    }

    /* Ensure the canvas fills its container normally */
    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Small utility to hide/show button area while fullscreen */
    .fullscreen-hide-controls #buttonarea { display: none !important; }
    </style>
</head>
<body>
    <!-- Optional rotate wrapper (script will use this if present) -->
    <div id="rotateWrapper" class="rotate-scale-wrapper" style="display:none">
      <div class="rotate-content" id="rotateContent">
        <!-- Canvas will be visually moved into this wrapper on fallback if needed -->
        <canvas tabindex="0" id="canvas" class="emscripten" oncontextmenu="event.preventDefault()"></canvas>
      </div>
    </div>

    <!-- Main layout (keeps original structure for UE4 bootstrap compatibility) -->
    <div class="wrapper" id="mainarea" style="min-height:100vh;">
        <div class="alert alert-warning centered-axis-xy" style="min-height: 20px; display:none;" role="alert" id="compilingmessage">
            <div id="loadTasks"></div>
        </div>

        <!-- If rotateWrapper is used, canvas is already present there. Keep a fallback canvas here if not using wrapper -->
        <!-- The inline style ensures the original template's canvas is present for UE4's loader if rotateWrapper isn't used -->
        <canvas tabindex="0" id="canvas_fallback" class="emscripten" oncontextmenu="event.preventDefault()" style="display:none;"></canvas>
    </div>

    <div class="buttonarea text-center" id="buttonarea" style="position:fixed; bottom:12px; left:0; right:0; z-index:100000;">
        <button type="button" class="btn btn-primary" id="about" data-toggle="modal" data-target="#aboutModal" title="$Abielon">
            <span class="glyphicon glyphicon-info-sign" aria-hidden="true"></span>
            <span class="buttontext">&nbsp;$Abielon</span>
        </button>

        <button type="button" id="pause" class="btn btn-primary" onclick="try { Module && Module['pauseMainLoop'] && Module['pauseMainLoop'](); $('#resume').show().focus(); $('#pause').hide(); } catch(e) {console.error(e);}" title="Pause" style="display:none">
            <span class="glyphicon glyphicon-pause" aria-hidden="true"></span>
            <span class="buttontext">&nbsp;Pause</span>
        </button>
        <button type="button" id="resume" class="btn btn-primary" onclick="try { Module && Module['resumeMainLoop'] && Module['resumeMainLoop'](); $('#pause').show().focus(); $('#resume').hide(); } catch(e) {console.error(e);}" title="Resume" style="display:none">
            <span class="glyphicon glyphicon-play" aria-hidden="true"></span>
            <span class="buttontext">&nbsp;Resume</span>
        </button>

        <button type="button" class="btn btn-primary" id="clear_indexeddb" onclick="try { deleteIndexedDBStorage(); } catch(e) {console.error(e);}" title="Clear IndexedDB" style="display:none">
            <span class="glyphicon glyphicon-trash" aria-hidden="true"></span>
            <span class="buttontext">&nbsp;Clear IndexedDB</span>
        </button>

        <button type="button" class="btn btn-primary" id="fullscreen_request" title="Fullscreen">
            <span class="glyphicon glyphicon-fullscreen" aria-hidden="true"></span>
            <span class="buttontext">&nbsp;Fullscreen</span>
        </button>
    </div>

    <!-- About modal preserved -->
    <div class="modal fade" id="aboutModal" tabindex="-1" role="dialog">
        <div class="modal-dialog modal-lg" role="document">
            <div class="modal-content">
                <div class="modal-body">
                    <div>Cash app as gift please, anything helps. -Your noble paladin Abielon @Keyless Abyss</div>
                    <div class="text-center">
                        <button type="button" class="btn btn-default" data-dismiss="modal" style="margin-bottom:0">
                            <span class="glyphicon glyphicon-remove" aria-hidden="true"></span>
                            <span class="buttontext">&nbsp;Close</span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="texthalf text-normal jumbotron" id="logwindow" style="display:none"></div>

    <!-- UE4 runtime loader -->
    <script src="Megatroid-HTML5-Shipping.UE4.js"></script>

    <!-- Fullscreen + orientation + rotate/scale fallback logic -->
    <script>
    (function () {
      const fsBtn = document.getElementById('fullscreen_request');
      // Prefer the rotate wrapper's canvas if present, otherwise fallback canvas; UE4 may populate the fallback canvas.
      const rotateWrapper = document.getElementById('rotateWrapper');
      const rotateContent = document.getElementById('rotateContent');
      const canvas = document.getElementById('canvas') || document.getElementById('canvas_fallback');
      const mainarea = document.getElementById('mainarea');

      // Ensure canvas exists in DOM where we expect it. If rotateWrapper exists, keep canvas inside rotateContent.
      if (rotateWrapper && rotateContent && canvas && canvas.parentNode !== rotateContent) {
        // Move any existing canvas into the rotateContent for fallback mode readiness.
        try {
          rotateContent.appendChild(canvas);
        } catch (e) { /* ignore if already moved */ }
      }

      // Compute a scale so a rotated (90deg) element covers the viewport fully
      function computeRotateScale(contentEl) {
        if (!contentEl) return 1;
        const contentWidth = contentEl.offsetWidth || contentEl.clientWidth || window.innerWidth;
        const contentHeight = contentEl.offsetHeight || contentEl.clientHeight || window.innerHeight;
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        // After rotating 90deg, contentWidth -> vertical size, contentHeight -> horizontal size.
        // We need scale so rotatedContentHeight >= vh and rotatedContentWidth >= vw
        const scaleX = vw / contentHeight;
        const scaleY = vh / contentWidth;
        return Math.max(scaleX, scaleY, 1);
      }

      // Apply rotate+scale transform to the content element to visually force landscape and fill viewport
      function applyRotateScale() {
        document.documentElement.classList.add('force-landscape-fallback');
        if (!rotateWrapper) return;
        rotateWrapper.style.display = 'flex';
        const contentEl = rotateContent || canvas;
        const scale = computeRotateScale(contentEl);

        // Center, rotate, and scale. Using translate(-50%,-50%) centers before rotation.
        contentEl.style.position = 'absolute';
        contentEl.style.left = '50%';
        contentEl.style.top = '50%';
        contentEl.style.transformOrigin = 'center center';
        contentEl.style.transform = `translate(-50%,-50%) rotate(90deg) scale(${scale})`;
        contentEl.style.width = ''; // allow natural sizing
        contentEl.style.height = '';
        // Hide normal UI controls so user sees just game canvas on fallback
        document.body.classList.add('fullscreen-hide-controls');
      }

      // Clear fallback transforms when exiting fullscreen or when orientation lock worked
      function clearRotateScale() {
        document.documentElement.classList.remove('force-landscape-fallback');
        if (!rotateWrapper) return;
        rotateWrapper.style.display = 'none';
        const contentEl = rotateContent || canvas;
        if (contentEl) {
          contentEl.style.transform = '';
          contentEl.style.position = '';
          contentEl.style.left = '';
          contentEl.style.top = '';
          contentEl.style.transformOrigin = '';
        }
        document.body.classList.remove('fullscreen-hide-controls');
      }

      // Attempt orientation lock; returns true if lock succeeded
      async function tryLockLandscape() {
        try {
          if (screen.orientation && screen.orientation.lock) {
            // try landscape-primary first; some devices prefer landscape-primary
            await screen.orientation.lock('landscape-primary');
            return true;
          } else if (screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation) {
            const lockFn = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
            lockFn.call(screen, 'landscape');
            return true;
          }
        } catch (e) {
          // lock failed/denied
        }
        return false;
      }

      // Generic requestFullscreen with vendor fallbacks
      async function requestFullscreenOn(el) {
        if (!el) return Promise.reject(new Error('No element'));
        if (el.requestFullscreen) return el.requestFullscreen();
        if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
        if (el.msRequestFullscreen) return el.msRequestFullscreen();
        return Promise.reject(new Error('No fullscreen API'));
      }

      // Handler that runs on first user gesture: request fullscreen then attempt to lock orientation.
      // If lock fails, apply rotate+scale fallback. After the first run, swap to a simpler fullscreen-only handler.
      async function firstTimeHandler(ev) {
        ev && ev.preventDefault && ev.preventDefault();

        const target = rotateWrapper || mainarea || document.documentElement;

        try {
          await requestFullscreenOn(target);
        } catch (err) {
          console.warn('requestFullscreen failed', err);
          // still try orientation on document if fullscreen unavailable
        }

        // First attempt lock immediately (some browsers allow lock right after requestFullscreen inside the same gesture)
        let locked = await tryLockLandscape();

        // If not locked yet, wait for fullscreenchange to attempt lock (some browsers need fullscreen state)
        if (!locked) {
          // Try locking again after a brief frame to allow fullscreen to settle
          await new Promise(r => setTimeout(r, 50));
          locked = await tryLockLandscape();
        }

        if (!locked) {
          // Apply CSS rotate+scale fallback to visually force landscape and fill viewport
          applyRotateScale();
        } else {
          clearRotateScale();
        }

        // Replace handler: subsequent clicks use simple fullscreen (no orientation logic)
        fsBtn.removeEventListener('click', firstTimeHandler);
        fsBtn.addEventListener('click', () => {
          const simpleTarget = rotateWrapper || mainarea || document.documentElement;
          requestFullscreenOn(simpleTarget).catch(() => {});
        }, false);
      }

      // Listen for fullscreen changes to re-attempt / clean up
      function onFullscreenChange() {
        const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
        if (isFs) {
          // When entering fullscreen, try lock again to catch browsers that only allow lock after fullscreenchange
          tryLockLandscape().then(locked => {
            if (!locked) applyRotateScale();
            else clearRotateScale();
          });
        } else {
          // Exited fullscreen: clear fallback transforms and unlock orientation if possible
          clearRotateScale();
          try { screen.orientation && screen.orientation.unlock && screen.orientation.unlock(); } catch (e) {}
        }
      }

      // Compute and reapply scale on resize while in fallback mode
      window.addEventListener('resize', () => {
        if (document.fullscreenElement && document.documentElement.classList.contains('force-landscape-fallback')) {
          applyRotateScale();
        }
      }, false);

      document.addEventListener('fullscreenchange', onFullscreenChange);
      document.addEventListener('webkitfullscreenchange', onFullscreenChange);
      document.addEventListener('msfullscreenchange', onFullscreenChange);

      // Attach the first-time handler to the button (user gesture)
      fsBtn.addEventListener('click', firstTimeHandler, false);

      // Optional: allow clicking the main canvas area to also trigger fullscreen if button hidden
      try {
        const clickableCanvas = canvas;
        if (clickableCanvas) {
          clickableCanvas.addEventListener('click', function (e) {
            // Only trigger if not already fullscreen
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
              firstTimeHandler(e);
            }
          }, false);
        }
      } catch (e) { /* ignore */ }

    })();
    </script>
</body>
</html>
```